#ifndef nle_routines_h_inluded
#define nle_routines_h_inluded

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    void stress_calc(double r, double e, double (&def_ten)[3][3], double (&stress)[3][3])
/// \brief Given energy (e), density (r) and deformation tensor (def_ten), calculate stress
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void stress_calc(double r, double e, double (&def_ten)[3][3], double (&stress)[3][3])
{

    //Calculating inverse of def_ten
    double inv_def[3][3] = {0.0};
    inverse_calc(def_ten,inv_def);

    double trans_def[3][3]= {0.0};
    transpose(def_ten,trans_def);

    double in_trans_def[3][3]={0.0};
    inverse_calc(trans_def,in_trans_def);

    double g[3][3]={0.0};
    matrix_mult(in_trans_def,inv_def,g);

    double b[3][3]={0.0};
    matrix_mult(def_ten,trans_def,b);

    double i1 = invariant_1(g);
    double i2 = invariant_2(g);
    double i3 = invariant_3(g);

    double aa[3][3]={0.0};
    unit_matrix(aa);

    double bb[3][3]={0.0};
    double cc[3][3]={0.0};

    for (int ii=0;ii<=2;ii++)
    {
        for (int jj=0;jj<=2;jj++)
        {
            bb[ii][jj] = i1*aa[ii][jj] - g[ii][jj];
            cc[ii][jj] = i3*b[ii][jj];
        }
    }

    double phi = e-(k0/(2.0*(alpha*alpha)))*(pow(i3,(alpha/2.0))-1.0)*(pow(i3,(alpha/2.0))-1.0);
    phi = phi - (b0/2.0)*(pow(i3,beta/2.0))*((i1*i1)/(3.0)-i2);
    phi = phi/(cv*t0*pow(i3,gamma/2.0));

    double e1 = (1.0/3.0)*b0*i1*pow(i3,beta/2.0);
    double e2 = -(1.0/2.0)*b0*pow(i3,beta/2.0);
    double e3 = 1.0/4.0*beta*b0*(1.0/3.0*i1*i1 - i2)*pow(i3,beta/2.0-1.0);
    e3 = e3 + (1.0/(2.0*alpha))*k0*(pow(i3,alpha/2.0-1.0))*(pow(i3,alpha/2.0)-1.0);
    e3 = e3 + (1.0/2.0)*t0*gamma*cv*pow(i3,gamma/2.0-1.0)*phi;


    for (int ii=0;ii<=2;ii++)
    {
        for (int jj=0;jj<=2;jj++)
        {
            for (int kk=0;kk<=2;kk++)
            {
            stress[ii][jj] = stress[ii][jj] + g[ii][kk]*(e1*aa[jj][kk] + e2*bb[jj][kk] + e3*cc[jj][kk]);
            }
            stress[ii][jj] = -2.0*r*stress[ii][jj];
        }
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    double nle_en_calc(double (&def_ten)[3][3], double s)
/// \brief Given deformation tensor (def_ten) and entropy (s) - return energy
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double nle_en_calc(double (&def_ten)[3][3], double s)
{
    //Calculating inverse of def_ten
    double inv_def[3][3] = {0.0};
    inverse_calc(def_ten,inv_def);

    double trans_def[3][3]= {0.0};
    transpose(def_ten,trans_def);

    double in_trans_def[3][3]={0.0};
    inverse_calc(trans_def,in_trans_def);

    double g[3][3]={0.0};
    matrix_mult(in_trans_def,inv_def,g);

    double i1 = invariant_1(g);
    double i2 = invariant_2(g);
    double i3 = invariant_3(g);


    double en = (k0/(2.0*alpha*alpha))*(pow(i3,alpha/2.0)-1.0)*(pow(i3,alpha/2.0)-1.0) + cv*t0*pow(i3,gamma/2.0)*(exp(s/cv)-1.0);
    en = en + b0/2.0*(pow(i3,beta/2.0))*(i1*i1/3.0 - i2);

    return en;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    void inverse_calc(double (&a)[3][3], double (&b)[3][3])
/// \brief Calculating inverse of a matrix a -> b
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void inverse_calc(double (&a)[3][3], double (&b)[3][3])//b to be inverse of a
{
    double deta = -a[0][2]*a[1][1]*a[2][0] + a[0][1]*a[1][2]*a[2][0] + a[0][2]*a[1][0]*a[2][1] - a[0][0]*a[1][2]*a[2][1] - a[0][1]*a[1][0]*a[2][2] + a[0][0]*a[1][1]*a[2][2];

    //Calculating inverse
    b[0][0] = (-a[1][2]*a[2][1] + a[1][1]*a[2][2])/deta;
    b[0][1] = (-a[0][1]*a[2][2] + a[0][2]*a[2][1])/deta;
    b[0][2] = (-a[0][2]*a[1][1] + a[0][1]*a[1][2])/deta;

    b[1][0] = (-a[1][0]*a[2][2] + a[1][2]*a[2][0])/deta;
    b[1][1] = (-a[0][2]*a[2][0] + a[0][0]*a[2][2])/deta;
    b[1][2] = (-a[0][0]*a[1][2] + a[0][2]*a[1][0])/deta;

    b[2][0] = (-a[1][1]*a[2][0] + a[1][0]*a[2][1])/deta;
    b[2][1] = (-a[0][0]*a[2][1] + a[0][1]*a[2][0])/deta;
    b[2][2] = (-a[0][1]*a[1][0] + a[0][0]*a[1][1])/deta;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    void transpose(double (&a)[3][3], double (&b)[3][3])
/// \brief Calculating transpose of a matrix a -> b
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void transpose(double (&a)[3][3], double (&b)[3][3])//b to be transpose of a
{
    for (int ii=0;ii<=2;ii++)
    {
        for (int jj=0;jj<=2;jj++)
        {
           b[ii][jj] = a[jj][ii];
        }
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    void matrix_mult(double (&a)[3][3], double (&b)[3][3], double (&c)[3][3])
/// \brief c = A.B (matrix multiplication)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void matrix_mult(double (&a)[3][3], double (&b)[3][3], double (&c)[3][3])//c = a.b
{
    for (int ii=0;ii<=2;ii++)
    {
        for (int jj=0;jj<=2;jj++)
        {
           for (int kk=0;kk<=2;kk++)
           {
                c[ii][jj] = c[ii][jj] + a[ii][kk]*b[kk][jj];
           }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    double invariant_1(double (&a)[3][3])
/// \brief Returns first invariant of 3X3 matrix a
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double invariant_1(double (&a)[3][3])
{
    return a[0][0]+a[1][1]+a[2][2];
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    double invariant_2(double (&a)[3][3])
/// \brief Returns second invariant of 3X3 matrix a
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double invariant_2(double (&a)[3][3])
{
    double i2 = a[0][0]*a[1][1] - a[0][1]*a[1][0] + a[1][1]*a[2][2] - a[1][2]*a[2][1] + a[2][2]*a[0][0] - a[2][0]*a[0][2];
    return i2;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    double invariant_3(double (&a)[3][3])
/// \brief Returns third invariant of 3X3 matrix a
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double invariant_3(double (&a)[3][3])
{

    double i3 = -a[0][2]*a[1][1]*a[2][0] + a[0][1]*a[1][2]*a[2][0] + a[0][2]*a[1][0]*a[2][1];
    i3 = i3 - a[0][0]*a[1][2]*a[2][1] - a[0][1]*a[1][0]*a[2][2] + a[0][0]*a[1][1]*a[2][2];

    return i3;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \fn    void unit_matrix(double (&a)[3][3])
/// \brief Populate a[][] values with unit matrix entries
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void unit_matrix(double (&a)[3][3])
{
    a[0][0]=1.0;
    a[0][1]=0.0;
    a[0][2]=0.0;

    a[1][0]=0.0;
    a[1][1]=1.0;
    a[1][2]=0.0;

    a[2][0]=0.0;
    a[2][1]=0.0;
    a[2][2]=1.0;
}

#endif // nle_routines_h_inluded
